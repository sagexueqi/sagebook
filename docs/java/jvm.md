# JVM

## JVM内存模型

![jvm_内存模型](./imgs/jvm_内存模型.png)

- 堆内存：
  - 年轻代：对象首先在Eden区完成分配，YGC后将Eden区存活的对象和S0或S1存活的对象，拷贝到另外一个区。各种GC回收器在这里都是使用的 **标记-复制** 算法
  - 年老代：经过15次YGC仍然存活或者在年轻代无法分配的对象，存放在年老代。年老代的垃圾回收没有年轻代频繁，FGC时回收。
- 栈内存：表示的是线程栈内存，局部变量、基本数据类型在栈内存上分配
  - 局部变量表：维持线程内方法的局部变量信息
  - 操作数栈：可以理解为计算区域
  - 方法出口：在方法嵌套调用时，需要知道当前方法执行完以后，跳回到哪里，和程序计数器配合使用
- 本地方法栈：Native方法的栈内存空间
- 程序计数器：方法嵌套调用时，总要只要当前方法执行到哪里，子函数完成后要跳转回来
- MetaSpace元空间：
  - Class类元信息：通过ClassLoader加载的类、动态代理生成的代理类信息
  - 常量
  - 静态变量

## Java对象内存分配策略
- 对象优先在Eden区进行分配：大多数情况下，对象在新生代的Eden区进行分配。当Eden区空间不足时，触发YGC
  - YGC后再次尝试在Eden区分配对象，如果仍无法分配，尝试在年老代分配对象
  - 年老代没有足够连续的空间分配对象，触发FGC(不绝对会触发YGC)后，再次尝试分配对象
  - 在FGC后仍然没有足够连续空间分配对象，退化成 `Serial Old GC` 基于 **标记-整理** 算法进行回收整理，再次分配对象
  - 如果全部分配失败，抛出 ```OutOfMemory``` 异常，JVM宕机应用不在提供服务
- 大对象直接在年老代进行分配：连续的数组、非常大的字符串。
  - 可以通过```-XX:PretenureSizeThreshold```指定大对象的阈值
  - 指定大对象也是有意义的，可以在一定程度上避免大对象在YGC时频繁的复制；但是，也会带来问题，大对象占用年老代空间，根据Java对象朝生夕死的特点，很久才会被FGC清除
- 长期存活的对象进入年老代：可以理解为被15次YGC后仍然存活的对象可以直接进入年老代
  - 可以通过```-XX:MaxTenuringThreshold```指定长期存活的阈值
  - 如果设置较小，会导致新对象过早的进入到年老代；而设置过大，会让本应该进入年老代存活的对象在YGC时频繁的复制

> 参考：https://www.cnblogs.com/xjshi/p/7338847.html

## GC垃圾回收
> MinorGC(YGC): 年轻代GC，因为Java对象具大多具备朝生夕死的特性，所以YGC会非常频繁，回收速度比较快
>
> MajorGC(FGC): 年老代GC，当出现FGC时，经常至少会伴随一次YGC(不绝对)。FGC的速度一般比YGC慢10倍以上。
>
> 要尽量减少系统FGC的频率,这也是我们做JVM调优的目标
>
> 无论是YGC还是FGC，都会有Stop The World的情况

### 垃圾对象的判断方式

**可达性分析算法：** 通过一系列成为 `GC-ROOT` 的对象作为起始点，从这些点看是向下搜索，搜索所走过的路径称为 `引用链`。当一个对象没有任何引用链（GC-ROOT不可达）时，说明这个对象是不可用的。

**可以作为GC-ROOT起点的对象:**
- 虚拟机栈内存中局部变量表引用的对象：因为局部变量表中维护着变量和堆内存对象的关系，如果当前对象的方法执行完成后，局部变量引用的对象可以被清除。
- 本地方法栈中引用的对象
> 可以抽象为：类中的每一个函数方法在执行完成后，局部变量的对象都会被回收
- 元空间中静态属性引用的对象: static属性作为类属性，除非将属性的值置为null，对象才会被回收(已经成为游离态)
- 元空间中的常量属性引用的对象

### 回收算法
- **标记-复制:** 年轻代垃圾回收器使用的算法，新对象在Eden区创建。YGC时将Eden+From和To区来回复制存活对象。

  *特点：整半区回收，无碎片问题、简单高效；只适用于年轻代，因为old区没有复制的目标区域*

- **标记-清除:** 年老代垃圾回收器使用的算法，标示垃圾对象，清除

  *特点：过程相对简单，但是只有清除过程，会产生内存碎片；容易因为没有连续空间分配空间，导致提前触发FGC整理内存空间*

- **标记-整理:** 年老代垃圾回收器使用的算法，整体流程与 **标记-清除** 一致，加入了内存整理的过程

  *特点：过程较为复杂、无碎片问题*

### 垃圾回收器
> 吞吐量(throughput): 指用户代码的运行时间，在整个CPU耗时的比值。吞吐量 = 用户代码运行时间 / (用户代码运行时间 + 垃圾回收运行时间)。`系统停顿次数越少，吞吐量越高。`
> 
> 暂停时间(pause times): 垃圾回收时，用户线程的暂停时间。`暂停时间越小，每次请求的响应时间会越快。`
> 
> * 吞吐量优先: 垃圾回收的频率不会很频繁，所以一次垃圾回收的更多，带来的是 `每次回收时用户线程响应时间相对较慢，但系统停顿的次数较少。`
>
> * 响应时间优先: 垃圾回收的频率相对较高，所以一次回收的垃圾不多，带来的是 `每次回收时用户线程停顿时间较短，响应较快，但系统停顿次数较多。`

**年轻代垃圾回收器**
- Serial串行收集器
- ParNew收集器
- Parallel Scavenge收集器

**年老代垃圾回收器**
- CMS收集器
- Parallel Old收集器
- Serial Old收集器

**G1垃圾回收器**

**垃圾回收器的组合关系**
![jvm_垃圾收集器组合](./imgs/jvm_垃圾收集器组合.png)


> G1与CMS的区别
>
> 使用Parallel Scavenge + Parallel Old 和 ParNew + CMS 的区别
> 
> 针对不同类型应用，如何选择垃圾收集器组合