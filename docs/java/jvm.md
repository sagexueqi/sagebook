# JVM

## JVM内存模型

![jvm_内存模型](./imgs/jvm_内存模型.png)

- 堆内存：
  - 年轻代：对象首先在Eden区完成分配，YGC后将Eden区存活的对象和S0或S1存活的对象，拷贝到另外一个区。各种GC回收器在这里都是使用的 **标记-复制** 算法
  - 年老代：经过15次YGC仍然存活或者在年轻代无法分配的对象，存放在年老代。年老代的垃圾回收没有年轻代频繁，FGC时回收。
- 栈内存：表示的是线程栈内存，局部变量、基本数据类型在栈内存上分配
  - 局部变量表：维持线程内方法的局部变量信息
  - 操作数栈：可以理解为计算区域
  - 方法出口：在方法嵌套调用时，需要知道当前方法执行完以后，跳回到哪里，和程序计数器配合使用
- 本地方法栈：Native方法的栈内存空间
- 程序计数器：方法嵌套调用时，总要只要当前方法执行到哪里，子函数完成后要跳转回来
- MetaSpace元空间：
  - Class类元信息：通过ClassLoader加载的类、动态代理生成的代理类信息
  - 常量
  - 静态变量

----

## Java对象内存分配策略
- 对象优先在Eden区进行分配：大多数情况下，对象在新生代的Eden区进行分配。当Eden区空间不足时，触发YGC
  - YGC后再次尝试在Eden区分配对象，如果仍无法分配，尝试在年老代分配对象
  - 年老代没有足够连续的空间分配对象，触发```FGC(不绝对会触发YGC)```后，再次尝试分配对象
  - 在FGC后仍然没有足够连续空间分配对象，退化成 `Serial Old GC（针对CMS搜集器场景）` 基于 **标记-整理** 算法进行回收整理，再次分配对象
  - 如果全部分配失败，抛出 ```OutOfMemory``` 异常，JVM宕机应用不在提供服务
- 大对象直接在年老代进行分配：连续的数组、非常大的字符串。
  - 可以通过```-XX:PretenureSizeThreshold```指定大对象的阈值
  - 指定大对象也是有意义的，可以在一定程度上避免大对象在YGC时频繁的复制；但是，也会带来问题，大对象占用年老代空间，根据Java对象朝生夕死的特点，很久才会被FGC清除
- 长期存活的对象进入年老代：可以理解为被15次YGC后仍然存活的对象可以直接进入年老代
  - 可以通过```-XX:MaxTenuringThreshold```指定长期存活的阈值
  - 如果设置较小，会导致新对象过早的进入到年老代；而设置过大，会让本应该进入年老代存活的对象在YGC时频繁的复制

> 参考：https://www.cnblogs.com/xjshi/p/7338847.html

----

## GC垃圾回收
> MinorGC(YGC): 年轻代GC，因为Java对象具大多具备朝生夕死的特性，所以YGC会非常频繁，回收速度比较快
>
> MajorGC(FGC): 年老代GC，当出现FGC时，经常至少会伴随一次YGC(不绝对)。FGC的速度一般比YGC慢10倍以上。
>
> 要尽量减少系统FGC的频率,这也是我们做JVM调优的目标
>
> 无论是YGC还是FGC，都会有Stop The World的情况

### 垃圾对象的判断方式

**可达性分析算法：** 通过一系列成为 `GC-ROOT` 的对象作为起始点，从这些点看是向下搜索，搜索所走过的路径称为 `引用链`。当一个对象没有任何引用链（GC-ROOT不可达）时，说明这个对象是不可用的。

**可以作为GC-ROOT起点的对象:**
- 虚拟机栈内存中局部变量表引用的对象：因为局部变量表中维护着变量和堆内存对象的关系，如果当前对象的方法执行完成后，局部变量引用的对象可以被清除。
- 本地方法栈中引用的对象
> 可以抽象为：类中的每一个函数方法在执行完成后，局部变量的对象都会被回收
- 元空间中静态属性引用的对象: static属性作为类属性，除非将属性的值置为null，对象才会被回收(已经成为游离态)
- 元空间中的常量属性引用的对象

----

### 回收算法
- **标记-复制:** 年轻代垃圾回收器使用的算法，新对象在Eden区创建。YGC时将Eden+From和To区来回复制存活对象。

  *特点：整半区回收，无碎片问题、简单高效；只适用于年轻代，因为old区没有复制的目标区域*

- **标记-清除:** 年老代垃圾回收器使用的算法，标示垃圾对象，清除

  *特点：过程相对简单，但是只有清除过程，会产生内存碎片；容易因为没有连续空间分配空间，导致提前触发FGC整理内存空间*

- **标记-整理:** 年老代垃圾回收器使用的算法，整体流程与 **标记-清除** 一致，加入了内存整理的过程

  *特点：过程较为复杂、无碎片问题*

----

### 垃圾回收器
#### 关于吞吐量和停顿时间

- 吞吐量(throughput): 指用户代码的运行时间，在整个CPU耗时的比值。吞吐量 = 用户代码运行时间 / (用户代码运行时间 + 垃圾回收运行时间)。`系统停顿次数越少，用户代码执行时间越长，吞吐量越高。`
- 停顿时间(pause times): 垃圾回收时，用户线程的暂停时间。`暂停时间越小，每次请求的响应时间会越快，用户体验越好。`
- 吞吐量优先: 垃圾回收的频率不会很频繁，所以一次垃圾回收的更多，带来的是 `每次回收时用户线程响应时间相对较慢，但系统停顿的次数较少。`
- 响应时间优先: 垃圾回收的频率相对较高，所以一次回收的垃圾不多，带来的是 `每次回收时用户线程停顿时间较短，响应较快，但系统停顿次数较多。`

#### 年轻代垃圾回收器
_全部使用```标记-复制```算法_

**Serial串行收集器**
- 单线程收集，工作时所有用户线程必须停止等待
- 适用于单核CPU、Client场景，只要不是频发发生GC，这是可以接受的

**ParNew收集器**
- 常用的年轻代垃圾收集器，关注于减少停顿时间
- 是Serial收集器的多线程版本，工作时所有用户线程停止等待，多个GC线程并行工作
- 适用于关注延时的WEB系统；只有它可以与CMS回收器配合使用

**Parallel Scavenge收集器**
- JDK1.8默认的回收器，关注于系统吞吐量，让用户代码获取更多的运行时间
- 工作模式：与ParNew整体一致
- 适用于关注吞吐的批量、科学计算系统；与Parallel Old年老代垃圾回收器配合使用

#### 年老代垃圾回收器
**Serial Old收集器**
- 基于 ```标记-整理``` 算法（还有压缩，Mark-Sweep-Compact）
- 单线程收集
- 作为CMS收集器的后备预案，即CMS年老代回收后仍没有内存分配对象时使用

**Parallel Old收集器**
- JDK1.8的默认老年代垃圾收集器
- 基于```标记-整理```算法；多线程并行收集，用户线程在GC期间完全暂停
- 与Parallel Scavenge年轻代垃圾收集器配合使用

![jvm_parallel_old](./imgs/jvm_parallel_old.png)

**Concurrent Mark Sweep(并发标记清理)-CMS收集器**
- 常用的老年代垃圾收集器
- 基于 ```标记-清除```算法：不进行压缩操作，会产生内存碎片；初始标记、重新标记阶段用户线程完全暂停；
- 与用户线程并发执行，减少应用停顿，尽量减少STW的时间，关注与系统响应时间；与ParNew年轻代垃圾回收器配合使用

![jvm_cms](./imgs/jvm_cms.png)
- 初始标记(STW): 仅**单线程**标记一下能直接被GC-ROOT关联到的对象，目的在于找到本地不需要被回收的对象的根；速度非常快；STW的原因在于要确认根对象；
- 并发标记: **单线程**从直接关联对象向下寻找存活对象，此时**应用线程并发**运行，可能会遗漏刚刚new出来的存活对象
- 重新标记(STW): 由于上一步的并发标记会导致部分刚刚new出来的对象被遗漏，此时为了保证收集的正确性，需要再次**GC线程并行**标记
- 并发清除: **单线程**与**应用线程并发**清除垃圾对象
- CMS的触发时机：
  - 对象分配内存不足，触发FGC
  - CMS默认是不会等到饱和时触发，而是根据```-XX:CMSInitiatingoccupancyFraction```参数的配置来指定，默认：68。即老年代使用大于等于68触发

#### G1垃圾回收器


#### 垃圾回收器的组合关系

![jvm_垃圾收集器组合](./imgs/jvm_垃圾收集器组合.png)

**为什么Parallel类的收集器只能和Parallel或者Serial组合？**
- Serial、PareNew、CMS、Serial Old回收器公用一套代码结构，因此可以自由搭配，只是根据不同的系统场景，进行不同的组合
- Parallel Scavenge和Parallel Old属于后来的代码框架，因此不能和其他四个随意搭配
- G1本身就有分代算法，也没有必要和其他垃圾回收器搭配
- Serial Old作为年老代收集失败的回退方案，其他的新生代垃圾回收器也要和它做兼容

> **针对不同类型应用，如何选择垃圾收集器组合**
> - 实时类应用系统：关注点在于降低请求的响应时间，应该使用```ParNew+CMS```垃圾收集器，一次垃圾回收停顿时间越短，用户体验越好
> - 批量类、后台运算类系统：关注点在于提升系统吞吐量，快速完成数值计算、报表处理等业务。而吞吐量是一个目标值，目的是让用户代码执行的时间在整个CPU时间的占比比较高，所以应该使用```Parallel Scavenge + Parallel Old```垃圾回收器组合
>
> **并发和并行回收的区别**
> - 并行(Parallel): 多条GC线程同时运行，此时用户线程会暂停。ParNew、Parallel Scavenge、Parallel Old
> - 并发(Concurrent): 用户线程和GC线程同时运行(不一定并行，可能会交替执行-这是CPU和操作系统调度决定的)，用户程序运行，而垃圾回收线程在另一个核上运行。CMS、G1
>
> 参考：https://www.cnblogs.com/cxxjohnson/p/8625713.html 