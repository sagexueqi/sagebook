# JVM内存模型

![jvm_jvm内存模型](./images/jvm_jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)

### 栈内存（线程）

**表示当前线程的栈内存，存放局部变量信息、基本数据类型都在栈内存上分配**

- 局部变量表：存放线程内方法的局部变量信息
- 操作数栈：基本数据类型的计算区域
- 方法出口：在方法嵌套调用时，需要知道被嵌套方法执行完成之后，需要跳回到哪里，配合`程序计数器`使用

### 堆内存

**Java对象分配的主要区域**

- 年轻代(Eden)：对象首先在Eden区完成分配，YGC后将Eden区存活的对象和S0或S1存活的对象，拷贝到另外一个区。各种GC回收器在这里都是使用的`标记-复制`算法。
- 年老代(Old)：经过15次（默认情况下）YGC仍然存活的对象或新分配的大对象，存放在年老代。年老代的垃圾回收没有年轻代频繁，FGC时回收。

### 本地方法栈

**Native方法的栈内存空间**

### 程序计数器

**方法嵌套调用时，总要记录下当前方法执行到哪里，子函数完成后要通过`方法出口`跳转回来**

### MetaSpace元空间

**替代JDK8前的方法区(PermGen)**

Class类元信息：通过ClassLoader加载的类、动态代理生成的代理类信息

_为什么从JDK8开始要使用MetaSpace替代方法区(PermGen)_

1. 在JDK7及以前，方法区(PermGen)是分配在Heap堆区的，在GC时也会被回收，降低GC回收的效率
2. Class类元信息比较难确定其大小，因此高效的使用方法区内存空间是比较困难的

_Metaspace内存管理_
 
1. 类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在Metaspace中的类元数据也是存活的，不能被回收
2. 每个加载器有单独的存储空间
3. 字符串常量池和类静态变量移入堆内存中，受GC管理
4. 当GC发现某个类加载器不再存活了，会把对应的空间整个回收

**参考**

> JVM学习——元空间（Metaspace）: https://www.jianshu.com/p/a6f19189ec62