# GC算法与回收器

## GC垃圾回收

### MinorGC、MajorGC与Old GC、FullGC

#### MinorGC

- 年轻代GC，即Young GC；以ParNew收集器为例，在GC日志中显示的是`[ParNew: 3412467K->59681K(3774912K), 0.0971990 secs] 9702786K->6354533K(24746432K), 0.0974940 secs] [Times: user=0.95 sys=0.00, real=0.09 secs]`
- 因为Java对象具大多具备朝生夕死的特性，所以YGC会非常频繁，回收速度比较快
- 在各种收集器中，YGC时都会暂停用户线程，即`stop the world`

#### MajorGC与Old GC

- 年老代GC，以CMS收集器为例，在GC日志中显示的是 `[GC (CMS Initial Mark) [1 CMS-initial-mark: 22630K(125696K)] 22743K(126848K), 0.0011803 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]`
- 对于不同的收集器，有不同的 `stop the world` 的阶段
  - CMS收集器在初始标记和重新标记阶段
  - Prarllel Old整个阶段
- 伴随着FullGC触发或大对象直接在年老代分配时触发

#### FullGC
- 对整个堆空间进行GC，一般是由于老年代或元空间内存不足、分配失败而触发
- GC日志中的显示`[Full GC (Ergonomics) [PSYoungGen: 544K->0K(9216K)] [ParOldGen: 6144K->6627K(10240K)] 6688K->6627K(19456K), [Metaspace: 3286K->3286K(1056768K)], 0.0063048 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]`
- 当出现FGC时，经常至少会伴随一次YGC(不绝对，可以通过不同收集器的参数进行配置)。FGC的速度一般比YGC慢10倍以上

### 垃圾对象的判断方式

**可达性分析算法：** 

通过一系列成为 `GC-ROOT` 的对象作为起始点，从这些点看是向下搜索，搜索所走过的路径称为 `引用链`。当一个对象没有任何引用链（GC-ROOT不可达）时，说明这个对象是不可用的。

**可以作为GC-ROOT起点的对象:**

- 虚拟机栈内存中局部变量表引用的对象：因为局部变量表中维护着变量和堆内存对象的关系，如果当前对象的方法执行完成后，局部变量引用的对象可以被清除。
- 本地方法栈中引用的对象
> 可以抽象为：类中的每一个函数方法在执行完成后，局部变量的对象都会被回收
- 静态属性引用的对象: static属性作为类属性，除非将属性的值置为null，对象才会被回收(已经成为游离态)
- 常量属性引用的对象

----

## GC算法

- **标记-复制:** 年轻代垃圾回收器使用的算法，新对象在Eden区创建。YGC时将Eden+From和To区来回复制存活对象。

  *特点：整半区回收，无碎片问题、简单高效；只适用于年轻代，因为old区没有复制的目标区域*

- **标记-清除:** 年老代垃圾回收器使用的算法，标示垃圾对象，清除

  *特点：过程相对简单，但是只有清除过程，会产生内存碎片；容易因为没有连续空间分配空间，由于空间担保机制导致提前触发FGC整理内存空间*

- **标记-整理:** 年老代垃圾回收器使用的算法，整体流程与 **标记-清除** 一致，加入了内存整理的过程

  *特点：过程较为复杂、无碎片问题*

----

## 垃圾回收器

*所有垃圾回收器都是STW的*

**关于吞吐量和停顿时间**

- 吞吐量(throughput): 指用户代码的运行时间，在整个CPU耗时的比值。吞吐量 = 用户代码运行时间 / (用户代码运行时间 + 垃圾回收运行时间)。`系统停顿次数越少，用户代码执行时间越长，吞吐量越高。`
- 停顿时间(pause times): 垃圾回收时，用户线程的暂停时间。`暂停时间越小，每次请求的响应时间会越快，用户体验越好。`
- 吞吐量优先: 垃圾回收的频率不会很频繁，所以一次垃圾回收的更多，带来的是 `每次回收时用户线程响应时间相对较慢，但系统停顿的次数较少。
- 响应时间优先: 垃圾回收的频率相对较高，所以一次回收的垃圾不多，带来的是 `每次回收时用户线程停顿时间较短，响应较快，但系统停顿次数较多。`

### 年轻代垃圾回收器

_全部使用```标记-复制```算法_

**Serial串行收集器**
- 单线程收集，工作时所有用户线程必须停止等待
- 适用于单核CPU、Client场景，只要不是频繁发生GC，这是可以接受的

**ParNew收集器**
- 常用的年轻代垃圾收集器，关注于`减少停顿时间`
- 是Serial收集器的多线程版本，工作时所有用户线程停止等待，多个GC线程并行工作
- 适用于关注延时的WEB系统；只有它可以与CMS回收器配合使用

**Parallel Scavenge收集器**
- JDK1.8默认的回收器，关注于系统吞吐量，让用户代码获取更多的运行时间
- 工作模式：与ParNew整体一致
- 适用于关注吞吐的批量、科学计算系统；与Parallel Old年老代垃圾回收器配合使用

### 年老代垃圾回收器

#### Serial Old收集器
- 基于 ```标记-整理``` 算法（还有压缩，Mark-Sweep-Compact）
- 单线程收集
- 作为CMS收集器的后备预案，即CMS GC 运行期间，Old 区预留的空间不足以分配给新的对象，此时收集器会发生退化

#### Parallel Old收集器
- JDK1.8的默认老年代垃圾收集器
- 基于`标记-整理`算法；多线程并行收集，用户线程在GC期间完全暂停
- 与Parallel Scavenge年轻代垃圾收集器配合使用
**工作流程**

  ![jvm_parallel_old](./images/jvm_parallel_old.png)

#### Concurrent Mark Sweep(并发标记清理)-CMS收集器

- 常用的老年代垃圾收集器
- 基于`标记-清除`算法：不进行压缩操作，会产生内存碎片；初始标记、重新标记阶段用户线程完全暂停；
- 与用户线程并发执行，减少应用停顿，尽量减少STW的时间，关注与系统响应时间；与ParNew年轻代垃圾回收器配合使用
**工作流程**

![jvm_cms](./images/jvm_cms.jpg)

- 初始标记(STW): 仅**单线程**标记一下能直接被GC-ROOT关联到的对象，目的在于找到本地不需要被回收的对象的根；速度非常快；STW的原因在于要确认根对象，否则一直没法确认。`JDK8之前为单线程，之后可以根据CMSParallelInitialMarkEnabled调整`
- 并发标记: **单线程**从直接关联对象向下寻找存活对象，此时**应用线程并发**运行，可能会遗漏刚刚new出来的存活对象
- 重新标记(STW): 由于上一步的并发标记会导致部分刚刚new出来的对象被遗漏，此时为了保证收集的正确性，需要再次**GC线程并行**标记
- 并发清除: **单线程**与**应用线程并发**清除垃圾对象；已经确认了垃圾对象，可以并发清除

**CMS GC的触发时机**

- 老年代的使用空间达到阈值，默认92%。如果Old区太小，CMS会频繁发生
- Eden区YGC前的空间担保，如果连续内存不足，会触发FGC（YGC + OGC）
- 动态检查，JVM会根据最近回收历史，预估下一次老年代GC的时间
- Metaspace区达到最大值，在收集Metaspace的垃圾时，会触发老年代的CMS GC

----

## JVM调优