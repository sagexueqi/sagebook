# Lock-锁

以MySQL InnoDB为基础进行锁的分析。

## 乐观锁

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。

逻辑概念，即使是乐观锁更新，还是会有悲观锁；更新操作会加排它锁。提交的时候才去锁定。

### 基于版本号实现乐观锁



**基于版本号实现的方式，适用于无状态流转的场景，这样即使由于并发冲突导致更新失败可以自旋重试到成功或明确失败**

### 基于状态机实现乐观锁

- 基于状态的流转实现，状态的流转是`有限有向`的
- 进行数据更新时，`WHERE`条件需要携带旧的`f_state`值并且更新记录新的`f_state`到下一个流转的状态
- 如果更新失败，表示记录有并发冲突，状态已经无法从当前流转到期望的值，结束流程或进行其他异常业务处理

**基于状态机实现的方式，适用于订单状态流转、定时任务捞取记录进行重试等场景**

----

## 悲观锁

与乐观锁相对应的是悲观锁。悲观锁就是在数据操作前，就已经认为该操作会出现数据冲突，所以在每次操作时要先获取对记录的锁之后，再进行操作。

与乐观锁相对应的是，悲观锁都是基于数据库能力实现的，需要使用的时候，直接通过数据库相关的语句即可。

**锁分类**

按照锁的类别，常见的可以分为：`共享锁S`和`排他锁X`；按照锁的粒度，常见的可以分为：`行锁`、`间隙锁`、`表锁`

### 共享锁S & 排他锁X

#### 共享锁S

其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。

- 任何事务不能进行修改(加X锁)
- 必须等到一个事务释放S锁，另一个事务才可以获取X锁
- 任何事务都可以对同一记录加S锁

**加锁方式**

```sql
SELECT * FROM T_USER LOCK IN SHARE MODE;
```

Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。 其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。

**死锁场景示例**

| Transction A | Transaction B | 说明 |
| ---- | ---- | ---- |
| `SET autocommit = 0;` | `SET autocommit = 0;` | 设置Session不自动提交 |
| `SELECT * FROM t_user_info WHERE f_id=100000 LOCK IN SHARE MODE;` | `SELECT * FROM t_user_info WHERE f_id=100000 LOCK IN SHARE MODE;` | 使用共享锁查询记录，此时行记录均上S锁 |
| `UPDATE t_user_info SET f_email='ad.xueqi@123.com' WHERE f_id=100000;` | - | 事务A更新记录，此时需要等待事务B释放S锁后，才可以加X锁 |
| waiting... | - |
| waiting... | `UPDATE t_user_info SET f_email='ad.xueqi@123.com' WHERE f_id=100000;` | 事务B更新记录，此时需要等待事务A释放S锁后，才可以加X锁 |
| Query OK, 0 rows affected (8.46 sec) | ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction | 两个事务互相等待锁释放，死锁，其中一个事务异常，另一个事务完成 |

#### 排他锁X

若某个事务对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁

- 其他事务可以无锁读，不可以加锁查询，无论是S锁还是X锁；所以是独占的
- 更新操作默认都会加X锁
- 排他锁是悲观锁的主要实现，通过排他锁可以将对记录的并发操作串行化

**加锁方式**

- 查询加锁：`SELECT  + FOR UPDATE`
- UPDATE语句均会加排他锁

### 行锁 & 表锁 & GAP锁

#### 行锁

多个事务操作同一行数据是，有且只有一个事务生效，其他事务均处于阻塞等待的状态。这样可以避免脏读等数据一致性的问题，其他事务可以操作同表的其他数据，提高单表并发度。

**加锁方式**

- 对于`UPDATE`、`DELETE`和`INSERT`语句，InnoDB会自动给涉及数据集加排他锁；
- 对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的通过`SELECT ... FOR UPDATE`加锁

**InnonDB的行锁是基于`索引`实现的，如果一条SQL语句没有使用到索引，则会退化为表锁**

#### 表锁

- 只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁

#### GAP锁

- 当我们用`范围条件`而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁
- 对于键值在`条件范围`内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）
- 若执行的条件是`范围`过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响；因此在实际开发中，针对并发较高的插入场景，我们要我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件

**目的：** 防止幻读，满足相关隔离级别的要求

**加锁条件:**

- 范围查询，申请共享或排它锁或RR隔离级别
- RR隔离级别，使用相等条件请求给一个不存在的记录加锁

----

## 加锁原则

----

## 死锁问题

**参考**

> 全面了解mysql锁机制（InnoDB）与问题排查: https://juejin.im/post/5b82e0196fb9a019f47d1823