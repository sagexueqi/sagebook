# Lock-锁

## 乐观锁

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。

逻辑概念，即使是乐观锁更新，还是会有悲观锁；更新操作会加排它锁。提交的时候才去锁定。

### 基于版本号实现乐观锁

- 数据表设置一个独立的`f_version`字段，标示记录的当前版本号
- 当进行数据更新时，`WHERE`条件需要携带旧的`f_version`值并且更新记录新的`f_version = f_version + 1`
- 如果更新失败，表示该记录有并发冲突，进而进行冲突处理流程（重试 or 结束）

_表结构示例_

| f_id | f_name | f_version | f_created_time | f_updated_time |
| --- | --- | --- | --- | --- |
| 1 | TEST | 1 | NULL | NULL |

```sql

 UPDATE t_user SET f_name='1', f_version=f_version + 1 WHERE f_id = 1 AND f_version = 1;

```

**基于版本号实现的方式，适用于无状态流转的场景，这样即使由于并发冲突导致更新失败可以自旋重试到成功或明确失败**

### 基于状态机实现乐观锁

- 基于状态的流转实现，状态的流转是`有限有向`的
- 进行数据更新时，`WHERE`条件需要携带旧的`f_state`值并且更新记录新的`f_state`到下一个流转的状态
- 如果更新失败，表示记录有并发冲突，状态已经无法从当前流转到期望的值，结束流程或进行其他异常业务处理

**基于状态机实现的方式，适用于订单状态流转、定时任务捞取记录进行重试等场景**

----

## 悲观锁

与乐观锁相对应的是悲观锁。悲观锁就是在数据操作前，就已经认为该操作会出现数据冲突，所以在每次操作时要先获取对记录的锁之后，再进行操作。

与乐观锁相对应的是，悲观锁都是基于数据库能力实现的，需要使用的时候，直接通过数据库相关的语句即可。

### 共享锁S & 排他锁X

#### 共享锁S

其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。

- 任何事务不能进行修改(加X锁)
- 必须等到一个事务释放S锁，另一个事务才可以获取X锁
- 任何事务都可以对同一记录加S锁

**加锁方式**

```sql
SELECT * FROM T_USER LOCK IN SHARE MODE;
```

Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。 其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。

**死锁场景示例**

| Transction A | Transaction B | 说明 |
| ---- | ---- | ---- |
| `SET autocommit = 0;` | `SET autocommit = 0;` | 设置Session不自动提交 |
| `SELECT * FROM t_user_info WHERE f_id=100000 LOCK IN SHARE MODE;` | `SELECT * FROM t_user_info WHERE f_id=100000 LOCK IN SHARE MODE;` | 使用共享锁查询记录，此时行记录均上S锁 |
| `UPDATE t_user_info SET f_email='ad.xueqi@123.com' WHERE f_id=100000;` | - | 事务A更新记录，此时需要等待事务B释放S锁后，才可以加X锁 |
| waiting... | - |
| waiting... | `UPDATE t_user_info SET f_email='ad.xueqi@123.com' WHERE f_id=100000;` | 事务B更新记录，此时需要等待事务A释放S锁后，才可以加X锁 |
| Query OK, 0 rows affected (8.46 sec) | ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction | 两个事务互相等待锁释放，死锁，其中一个事务异常，另一个事务完成 |

#### 排他锁X

若某个事务对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁

- 其他事务可以无锁读，不可以加锁查询，无论是S锁还是X锁
- 更新操作默认都会加X锁
- 排他锁是悲观锁的主要实现，通过排他锁可以将对记录的并发操作串行化

**加锁方式**

- 查询加锁：`SELECT  + FOR UPDATE`
- UPDATE语句均会加排他锁

### 行锁 & 表锁

----

## 加锁原则

----

## 死锁问题

**参考**

> 全面了解mysql锁机制（InnoDB）与问题排查: https://juejin.im/post/5b82e0196fb9a019f47d1823