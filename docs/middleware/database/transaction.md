# Transaction-事务

## 事务特性

**Actomic原子性：** 事务中包含的操作被看做是一个完整的业务单元。这个业务单元中的操作，要么全成功，要么全失败。

**Consistency一致性：** 事务在完成时，必须所有的数据都保持一致的状态，在数据库中的修改都基于事务，保证数据一致性

**Isolation隔离性：** 只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰

**Durability持久性：** 事务结束后，所有的数据都会固化到一个地方

### 事务的并发问题

<!-- tabs:start -->

#### **脏读**

定义：一个事务读取到另外一个还没有提交的数据

#### **不可重复读**

定义：同一个事务中针对`同一记录`的多次查询，查询结果不一致。事务A读取到事务B提交的修改操作

_例如:A B两个事务,A先后两次查询到了相同的结果集,这时B对进行了相关的数据操作,导致A再读取的结果不一致_

> 侧重于两个事务中，对`同一条记录`的操作可见性问题

#### **幻读**

定义：同一事务中，`相同查询条件`的多次查询，得到的记录数不一致。事务A读取到事务B提交的修改操作

_例如：分页查询的场景，会出现记录数越来越多的情况，这就是幻读；幻读很多时候都是可以接收和允许的_

> 侧重于两个事务中，对同一查询条件的`读取的记录数`是否一致的问题

<!-- tabs:end -->

----

## 事务隔离级别

### Read Uncommit 读未提交

读到其他事务未提交的数据，该隔离级别不会使用，忽略

问题：脏读

### Read Commit 读已提交

只能读到其他事务已提交的数据，每次SELECT均创建一个新的`ReadView`保证

问题：幻读、不可重复读

> 常用的隔离级别，在保证事务隔离安全的情况下，提高并发度

### Repeatable Read 可重复读

- 事务内对于同一条记录的查询返回结果一致

    - 当前事务首次执行SELECT时创建ReadView
    - 所有快照读的SELECT都走这个readview
    - 当前事务的写操作，操作ReadView，不走当前读

- 对读取到的记录加锁（记录锁）

- 同时保证对读取的范围加锁，新的满足条件的记录不能被插入（Gap锁）

- 产生`幻读`的场景

    - 场景1：其他事务有写操作并提交，当前事务做当前读操作(insert/update/delete/select for update)会幻读
    - 场景2：A事务先查询结果，B事务添加一条新记录并提交；A事务再次查询，由于可重复读不会读到这条数据；但是更新B新增的这条记录可以成功（原因：MVCC）
    > 原因：直接或间接执行了「当前读」,导致ReadView更新,所以会读到新的

### Serializable 串行化

- 读取加读锁（S锁，共享锁）；写入加写锁（X锁，排它锁）

- 读写是冲突的，因此并发能力下降，但是可以避免上述所有问题

- 从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为`当前读`
