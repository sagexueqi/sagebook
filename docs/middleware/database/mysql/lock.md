# Lock - 锁

## 乐观锁 & 悲观锁

### 乐观锁

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。

逻辑概念，即使是乐观锁更新，还是会有悲观锁；更新操作会加排它锁。提交的时候才去锁定。

#### 乐观锁的实现方式

乐观锁，大多数是基于数据版本(version)机制实现。所谓的数据版本，即为数据增加一个版本标示，一般来说为数据表新增一个类似`version`的字段。

**基于版本号实现乐观锁**

- 数据表设置一个独立的`f_version`字段，标示记录的当前版本号
- 当进行数据更新时，`WHERE`条件需要携带旧的`f_version`值并且更新记录新的`f_version = f_version + 1`
- 如果更新失败，表示该记录有并发冲突，进而进行冲突处理流程（重试 or 结束）

_表结构示例_

| f_id | f_name | f_version | f_created_time | f_updated_time |
| --- | --- | --- | --- | --- |
| 1 | TEST | 1 | NULL | NULL |

_SQL示例_

`UPDATE t_user SET f_name='1', f_version=f_version + 1 WHERE f_id = 1 AND f_version = 1;`

> 基于版本号实现的方式，适用于无状态流转的场景，这样即使由于并发冲突导致更新失败可以自旋重试到成功或明确失败

**基于状态机实现乐观锁**

- 基于状态的流转实现，状态的流转是`有限有向`的
- 进行数据更新时，`WHERE`条件需要携带旧的`f_state`值并且更新记录新的`f_state`到下一个流转的状态
- 如果更新失败，表示记录有并发冲突，状态已经无法从当前流转到期望的值，结束流程或进行其他异常业务处理

> 基于状态机实现的方式，适用于订单状态流转、定时任务捞取记录进行重试等场景

----

**参考**

> Innodb中的事务隔离级别和锁的关系: https://tech.meituan.com/2014/08/20/innodb-lock.html