# 消息丢失与幂等

## 消息丢失

消息的的处理一般分为三个阶段：`生产、存储、消费`；每个阶段在处理消息防丢失的时候，都有不同的处理策略。

![消息丢失_1](./imgs/消息丢失_1.png)

### 生产阶段

生产者保证消息不丢失是所有方案的基础，如果生产者消息都没有发出去，那后续的流程也就不存在。一般来说，生产阶段防止消息丢失的方案主要从两个思路出发：持久化和消息生产者客户端配置

#### 消息持久化方案

![消息丢失_2](./imgs/消息丢失_2.png)

**流程**

- 开启数据库事务，执行业务流程
- 组装待发送的Message信息，在当前事务中保存到消息表中
- 提交事务；如果执行中有异常，依赖事务实现，保证消息也被回滚（类似于分布式事务中的消息事务）
- 定时任务捞取消息，乐观锁更新到中间状态，并发送到broker：同步发送成功后，更新记录状态，避免消息重复投递 或 发送后监听回调，更新记录状态

**方案总结**
- 延迟：消息发送的延迟时间要考虑定时任务的周期，从发送到投递成功，可能需要经过更长的时间
- 实现成本：高。需要建立独立的表和任务；客户端持久化方案也可以进一步延伸为Broker代理持久化方案，总是要引入新的逻辑和中间件
- 可靠性：高。消息只要被事务持久化成功，抛出不可抗力的故障，消息数据在Producer端不会丢失
- 替代方案：基于log的持久化。可以在代码中直接使用mq的client发送消息，在log中记录消息的发送状态，如果失败的话，基于日志处理并重新push

#### 生产客户端配置

不是所有的场景都需要基于持久化方案，在绝大部分场景或者可以容忍由于硬件故障导致消息丢失的情况下，我们还是优先考虑基于客户端配置来保证消息防丢失

**以Kafka为例**

- 除非是明确的oneway场景，否则不要只使用`send()`方法
- `acks`可以配置为`all`，必须得到broker所有副本的接收确认，消息才算是已提交，否则producer还会尝试重新投递消息
> Q1: 设置`acks=all`就一定保证消息不会丢失？
>
> A1: 不一定。Partition只有一个副本，也就不存在同步一说，Brokder没有刷盘，消息还是会丢失
>
> Q2: 设置`acks=1`为什么会丢消息？
>
> A2: 要先搞明白`acks=1`的流程，Producer只要将消息发送到Leader Partiton并刷盘就算成功；但是，如果Leader 还没有开始同步到副本后就宕机，此时从副本中选出的Leader并没有当前消息，消息丢失
- `retries`的配置值不要太小，由于网络抖动问题导致消息投递失败、超时等原因，由Producer自动重发，如果重试次数太小，消息无法尽最大努力投递；既然重试，就一定会遇到重复消费的问题

----

### 存储阶段

消息存储阶段，主要是针对Broker节点，基于Broker配置和高可用集群部署的方案，来保证消息的不丢失。

**以下均以kafka为例**

#### Broker配置

#### 高可用部署

----

### 消费阶段

----

## 消息幂等

或 重复消费、消息一致性问题