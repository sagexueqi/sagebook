# 安全

## 安全编码

**Java编码时需要考虑的安全问题**

- 资源释放：
  - 在finally代码块中关闭打开的资源；
  - 基于JAVA7的`try-with-resources`特性，对于实现`Autocloseable`接口的资源，可以在`try`语句块中创建，之后会自动关闭

  ```java
    try (InputStream is = new FileInputStream(src);
        OutputStream os = new FileOutputStream(tar);) {
            byte[] b = new byte[1024];
            int len;
            while ((len = is.read(b)) != -1) {
                os.write(b);
            }
    } catch (IOException e) {
        e.printStackTrace();
    }
  ```
- 数值计算问题:
  - 针对支付（退款）金额、收取（退还）手续费这种有含义的字段，建议全部使用正数传递；在代码逻辑中根据业务场景进行`+`/`-`运算
  - 针对账户余额非负的保证：一种是SQL做`-`运算时，使用条件`当前余额>扣减金额`；或者将余额字段设置为`decimal unsinged`的无符号类型，字段值只可以为正数，具体`+`/`-`逻辑在业务代码中实现

**在设计WEB API时需要考虑的安全问题**
- XSS、

> 参考陌陌安全团队的JAVA安全编码指南：
>
> https://github.com/momosecurity/rhizobia_J/wiki/JAVA%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83#14

----

## 常见加解密算法

----

## 服务CA双向认证

### 基础概念

- **PKI:** 公钥基础设施（Public Key Infrastructure）。所有与数字证书相关的各种概念和技术，统称为PKI。
- **CA:** 证书签发机构（Certificate Authority）。正常来说，CA应该是权威签发机构，例如独立第三方、CFCA、国家广州CA、国家深圳CA；但我们在服务API传输场景中，也是可以由约定方签发生成证书。
- **根证书:** 可以理解为CA证书，由CA自己颁发，这个证书代表了CA自己。浏览器客户端中内置了一些权威机构的根证书。如果是可信RPC、服务通讯，也可以使用自签发根证书安装到本地。
- **数字证书:** 基于根证书签发的证书。如果站点是对外使用，这个证书一般需我们去买购买。
- **单向认证:** 网络通讯是双向的，认证不一定都是双向的。大多数情况下，客户端只需要验证服务端是否合法可靠的，服务端不管客户端的问题。即，在https传输中，浏览器会验证服务端证书，服务端不验证客户端证书。
- **双向认证:** 相对于单向认证，双向认证的过程中，服务端也需要认证客户端是否可靠，双方都需要验证证书。
- **秘钥文件：** 存放自己的公私钥和对方的公钥
- **Key Store:** 存放自己的公钥和私钥
- **Trust Store:** 存放别人的公钥

### 整体流程
**证书生成阶段：**
- 服务端和客户端生成各自的秘钥文件: `*.jks`
- 根据各自的 `*.jsk` 文件，导出服务端和客户端的证书: `*.cer`
- 服务端和客户端分别将对方的证书导入到自己的`*.jsk`中：可以抽象的理解为证书就是公钥，秘钥文件是可以存放自己公私钥和对方公钥的

> 通过上面的流程可知，各自的`*.jks`是非常重要的，里面存放了自己的公私钥和所有可以信任的证书信息
>
> 证书文件在导入后可以理解为没有作用了，因为已经将对方的证书写入到自己的jks中了

**服务端配置**
- 指定服务的`key-store`和`trust-store`为同一个jks文件
- 指定服务端证书的`alias`别名，这样客户端会根据别名取对应的证书验证

**客户端配置**
- 根据客户端的`jks`文件，生成通用的`p12`秘钥文件
- 导入浏览器或调用客户端中

参考：
> Https双向认证：https://zhuanlan.zhihu.com/p/138238750
>